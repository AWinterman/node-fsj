#!/usr/bin/env node

var blobify = require('./')
  , nopt = require('nopt')
  , options

options = {
    'links': Boolean
  , 'ignore': String
  , 'help': Boolean
  , 'file-transform': String
}

shorthands = {
    'l': ['--links']
  , 'i': ['--ignore']
  , 'h': ['--help']
  , 'f': ['--file-transform']
}

var docs = (function() {/*
  usage: fs-json [dirs|files]

    Writes a json blob to stdout, with all the contents of all the files in it.

    Options:

    -l, --links:

        follow symbolic links, recursively descending whatever the
        link points to, as well.

    -i, --ignore regex:

        Paths matching this JavaScript regex are excluded

    -f, --file-transform

        The path to an executable process that listens for file data on stdin
        and writes some transform of the above to stdout. For example:

          fsj -f $(grep ack)

        will result in a json blob whose values are only those lines containing
        "ack".

*/}).toString()

docs = docs.slice(docs.indexOf('\n') + 1, docs.lastIndexOf('*/'))

var args = nopt(options, shorthands, process.argv, 2)

var options = {}
  , files

for(var key in args) {
  if(key === 'argv') {
    continue
  }

  if(key === 'ignore') {
    options[key] = new RegExp(args[key])

    continue
  }

  options[key] = args[key]
}

files = args.argv.remain

if(options.help || !files.length) {
  process.stderr.write(docs)
  process.exit(0)
}

blobify(files, {}, options, ready)

function ready(err, data) {
  if(err) {
    return on_error(err)
  }

  process.stdout.write(JSON.stringify(data))
  process.exit(0)
}

function on_error(error) {
  process.stderr.write(error.toString())
  process.exit(1)
}
